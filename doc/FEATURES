# Common adva engines behaviour

...


# Vertical code slices

...


# Controller abstraction

adva-cms2 makes heavy use of controller abstraction using inherited_resources and inherited_resources_helpers.

Therefor the shipped controllers are nearly empty and just carry a few required customizations.

The main reason for this is that we need to be able to respond to controller actions using Rails 3 responders so that process flow logic can be changed dynamically. This is a requirement by adva-business, the company driving the development of adva-cms2.

But it also has huge advantages for any developer who's just interested in using and maybe extending adva-cms2 for custom needs because abstraction generally enables extensibility and portability in many ways.

TODO: example using collection in blog views and then being able to apply scopes from plugins/other engines

# Central registry and redirect responder

Like its predecessor adva-cms2 comes with a central Registry for storing configuration and other values. One main use for this is that redirects that happen after controller actions can be configured in a central file in config/redirects.rb

Any adva engine will look for a file named this and read it. The file can register controller actions to be redirected to certain URLs. This configuration will then be used by the Adva::Responder::Redirect responder (unless the controller has chosen not to use responders of course).

See:

* adva-core/lib/adva/responder/redirect.rb
* adva-core/lib/adva/registry.rb
* [engine]/config/redirects.rb


# Object-oriented views

Rails' default architecture using ERB (or any other non-oop templating system) and helpers for views has a number of major drawbacks. For adva-cms2 the most relevant one is that non-oop templates are not extensible. Similarly overwriting Rails helpers based on certain contexts is not an easy and intuitive thing and therefor not commonly done.

adva-cms2 therefor takes a different route - and even in the short life of adva-cms2, our own (so far intern) extensions and customer application we believe that using pure Ruby code for our views was a really successul decision.

With adva-cms2 you can still use the classical Rails ERB/helper style. In fact you can use any templating system you want. But you can also opt for object-oriented views using the minimal/template library. These object-oriented views look a lot like what you might have seen from Markaby or Erector (which are older implementations of the same concept), but they fully leverage the very extensible capabilities of ActionPack 3.

For example the adva-user engine comes with a user form base class which is re-used by several user related actions (such as registration, confirmation etc., deriving from Devise). Imagine you need to add a certain link to this form. With object-oriented views you can simply inherit the base class and overwrite one of the ("helper") methods it comes with. Or you can include a module. Or do anything else that Ruby enables you to do. It's just Ruby and just as extensible and flexible as any other class that you work with.

Obviously object-oriented views are a starting point for disucussions about topics such as how designers could work with views that entirely consist of pure Ruby code. But from our point of view the major advantages of using object-oriented views, implemented as classes and thus unlocking all the power Ruby comes with for our views by far outrules such drawbacks. (And ... in our experience frontend developers are quite a smart bunch of people. Who ever is able to make sense from a regular real-life ERB template will probably be able to grasp a Ruby view as well, at least with some guidance or pairing.)


# STI Controllers and internal redirects

We haven't come up with a really good name for this abstraction, but it's certainly not only useful in adva-cms2.

What it means is: If you have an STI model like Section, Blog, Page where Section is the base model then in your controller(s) you sometimes want to have common behaviour for all these models on most actions, but special behaviour on some other actions.

adva-cms2 implements a concept of an "abstract" controller and related "concrete" controllers that makes it possible to have certain actions handled by the "abstract" or "concrete" controllers without changing any routes. E.g. when there is a Blog with the id 1 and a route maps /admin/sections/1 to sections#show but you've configured this action to be handled by its "concrete" counterpart then this request would be handled by the BlogController, not the SectionController.

This is implemented using another feature that could be used separately and that we call "internal redirects". Internal redirects just force a request to be handled by a different controller action than the one that is pointed to by your routes - without going through an HTTP redirect. In the example above the request is originally pointed to the SectionController's show action (by the routes) but it is internally redirected to the BlogController's show action.

See:

* adva-core/lib/adva/controller/abstract_actions.rb and
* adva-core/lib/adva/controller/internal_redirect.rb


# url_for fallbacks

...


# STI associations

...


# Anonymous modules inclusion

Ruby does not (yet) include an ability to "push" a module before a class' implementation in the class' module chain. That means that if a class implements a method #foo then it is not possible to overwrite that method by including a module to that class. (Instead one can only inherit the class or use alias_method_chain.)

For a while many libraries started using a Base module for that reason. They'd include the Base module into an otherwise empty class that's intended to be used. This class could now be easily extended by just including other modules that overwrite certain methods.

The Base module does not provide any other value than compensating for this "missing" Ruby feature. Therefor we can implement this whole concept better by just including an anonymous module. Including anonymous modules looks less noisy and heavyweight but provides the same extensibility.

Because adva-cms2 wants to be as extensible as possible it includes anonymous modules at many places.

See:

* adva-core/lib/core_ext/ruby/module/include_anonymous.rb

For a more detailled explanation how this concept works in the I18n gem see "this talk at Euruko 2010":http://vimeo.com/12665914


# Testing setup and framework additions


# Thor

Why we use thor, not rake ...


-----------------------------------------------

# Routing filters

(only makes sense in the context of a more concrete description of how an adva-cms2 site is build up, i.e. Site, Section tree etc.)

